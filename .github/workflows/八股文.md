# c++基础八股文

另外的八股文链接

https://github.com/huihut/interview#cc

#### **1、什么是多态机制？**

面向对象的三大特征：封装、继承和多态。

多态就是说同一个名字的函数可以有多种不同的功能。分为编译时的多态和运行时的多态。编译时的多态就是函数重载，包括运算符重载，编译时根据实参确定调用哪个函数。**运行时的多态则和虚函数（依赖于虚函数表）、继承有关。**



#### **2、那多态底层实现是怎么样的？**

利用虚函数表，先构建一个基类，然后在基类的构造函数中会建立虚函数表，也就是一个储存虚函数地址的数组，内存地址的前四个字节保存指向虚函数表的指针，然后当多个子类继承父类之后，主函数中可以通过父类指针调用子类的继承函数。

虚函数表属于类，也属于它的子类等各种派生类。虚函数表由编译器在编译时生成，保存在.rdata只读数据段。

**那子类的多态函数是怎么被调用的？**

因为每个子类都继承并设置了自己的虚函数表，每次用用父类指针创建新子类时就会出现，从而最终调用自己的表。

**怎么知道多态时，指向哪个虚函数？**

定义的父类指针new出哪个子类就是指向哪个子类的虚函数。（即根据对象实际类型来判断）

**对象怎么找到对应的虚函数表？**

```
( *( *(p+0) + 0 ) )(p); p是父类指针，p+0是指针vfptr，该指针指向虚函数表的首地址。所以*(p+0)即虚函数表的地址，( *(p+0) + 0 )就是要找的虚函数的地址，+0代表该虚函数在表中的偏移量。( *( *(p+0) + 0 ) )(p)表示对该函数的调用。
```

**虚函数表的结构是怎样的？**

虚函数表是一个函**数指针数组，**数组里存放的都是函数指针，指向虚函数所在的位置。 对象调用虚函数时，会根据虚指针找到虚表的位置，再根据虚函数声明的顺序找到虚函数在数组的哪个位置，找到虚函数的地址，从而调用虚函数。

虚函数表存储在进程的只读数据段。

**A,B两个类，类中有虚函数。C继承AB，有几张虚函数表？**

答：2张

再问：为什么2张？

多继承就会有多个虚函数表。因为每个父类的虚函数是不同的，指针也是不同的。

如果共用一张虚函数表，就分不清到底子类的实例化是针对哪一个基函数的。

参考链接：[虚函数表精讲教程，直戳多态的实现机制](https://link.zhihu.com/?target=http%3A//c.biancheng.net/view/vip_2300.html) （这篇文章讲的非常通透）



#### **3、父类构造函数中是否可以调用虚函数？（问了3次了，非常重要！！！ ）**

可以。不过调用会屏蔽多态机制，最终会把基类中的该虚函数作为普通函数调用，而不会调用派生类中的被重写的函数。

这是因为在定义子类对象的时候，会先调用父类的构造函数，**而此时虚函数表以及子类函数还没有被初始化，为了避免调用到未初始化的内存**，C++标准规范中规定了在这种情况下，**即在构造子类时调用父类的构造函数，而父类的构造函数中又调用了虚成员函数，这个虚成员函数即使被子类重写，也不允许发生多态的行为。**所以使用的是静态绑定，调用了父类的函数。

这段话讲的很好，但是不好理解，多看几遍：

构造函数调用层次会导致一个有趣的两难选择。试想：如果我们在构造函数中并且调用了虚函数，那么会发生什么现象呢？在普通的成员函数中，我们可以想象所发生的情况——虚函数的调用是在运行时决定的。这是因为编译时这个对象并不能知道它是属于这个成员函数所在的那个类，还是属于由它派生出来的某个类。于是，我们也许会认为在构造函数中也会发生同样的事情。

然而，情况并非如此。对于在构造函数中调用一个虚函数的情况，被调用的只是这个函数的本地版本。也就是说，虚机制在构造函数中不工作。

这种行为有两个理由：

第一个理由是概念上的。

在概念上，构造函数的工作是生成一个对象。在任何构造函数中，可能只是部分形成对象——我们只能知道基类已被初始化，但并不能知道哪个类是从这个基类继承来的。然而，虚函数在继承层次上是“向前”和“向外”进行调用。它可以调用在派生类中的函数。**如果我们在构造函数中也这样做，那么我们所调用的函数可能操作还没有被初始化的成员，这将导致灾难发生。**

第二个理由是机械上的。

当一个构造函数被调用时，它做的首要的事情之一就是初始化它的VPTR。然而，它只能知道它属于“当前”类——即构造函数所在的类。于是它完全不知道这个对象是否是基于其它类。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码——既不是为基类，也不是为它的派生类（因为类不知道谁继承它）。所以它使用的VPTR必须是对于这个类的VTABLE。而且，只要它是最后的构造函数调用，那么在这个对象的生命期内，VPTR将保持被初始化为指向这个VTABLE。**但如果接着还有一个更晚派生类的构造函数被调用，那么这个构造函数又将设置VPTR指向它的VTABLE**，**以此类推，直到最后的构造函数结束。VRTP的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是按照从基类到最晚派生类的顺序的另一个理由。**

但是，当这一系列构造函数调用正发生时，每个构造函数都已经设置VPTR指向它自己的VTABLE。如果函数调用使用虚机制，它将只产生通过它自己的VTABLE的调用，而不是最后派生的VTABLE（所有构造函数被调用后才会有最后派生的VTABLE）。另外，许多编译器认识到，如果在构造函数中进行虚函数调用，应该使用早绑定，因为它们知道晚绑定将只对本地函数产生调用。无论哪种情况，在构造函数中调用虚函数都不能得到预期的结果。



——来自《C++编程思想》合订本第386页



**构造函数可以是虚函数吗？为什么？**（c++不支持虚构造函数）

​		不可以，因为**虚函数存在的唯一目的就是为了多态。**而子类并不继承父类的构造函数，构造函数是创建对象时自己主动调用的，不可能被继承，所以没有使父类构造函数变成虚函数的必要。另外，父类在构造函数中创建虚函数表，实例化类对象，如果构造函数成为虚函数，那么因为类对象没有实例化导致不可能后续出现虚函数。

​		首先，虚函数的唯一存在的原因就是为了构成多态，但是派生类并不继承构造函数，构造函数是在创建对象时自己主动调用的，不可能通过子类的指针或者引用去调用继承。所以没必要（主要原因）。另一方面，构造函数为类对象初始化了内存空间，里面保存指向虚函数的指针vfptr，如果构造函数是虚函数，导致没有实例化类对象，也就没有内存空间，也就不可能有虚函数。

**静态函数可以是虚函数么？为什么？**

1. static成员**不属于任何类对象或类实例**，所以即使给此函数加上virutal也是没有任何意义的。
2. 静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数**没有this指针**。所以无法访问vptr. 进而不能访问虚函数表。



**虚函数的安全性有什么问题？**

可以通过虚函数表，让父类指针访问子类的自有虚函数。这带来一定的安全问题。另外，即使父类的虚函数是**私有函数或者保护函数，仍然可以通过虚函数表访问**，带来一定的安全问题。



#### **4、析构函数可以是虚函数吗？为什么？**

当析构函数是非虚函数时，主函数通过指针访问非虚函数时，**编译器会根据指针的类型来确定要调用的函数；而指针是父类指针，所以调用父类的析构函数。**

析构函数必须是虚函数。因为如果不是虚函数，**当在主函数中用父类的指针new出一个子类对象，最后析构的时候，只会调用父类析构函数而不会调用子类析构函数。而且如果不为虚函数，父类指针就不会调用子类成员函数。**

父类析构函数成为虚函数时，子类的析构函数会自动也变为虚函数。这个时候编译器会忽略指针的类型，而根据指针的指向来选择函数；也就是说，指针指向哪个类的对象就调用哪个类的函数。pb、pd 都指向了派生类的对象，所以会调用派生类的析构函数，继而再调用基类的析构函数。

参考链接：[虚析构函数的必要性](https://link.zhihu.com/?target=http%3A//c.biancheng.net/view/vip_2297.html)

**析构函数可以是纯虚函数么？**

析构函数可以是纯虚的，但纯虚析构函数必须有定义体，*因为析构函数的调用是在子类中隐含的*。

答案是可以，那么这样实现的目的是什么呢？当然是**避免实例化**。

但因为**派生类不可能来实现基类的析构函数**，所以**基类析构函数虽然可以标为纯虚，但是仍必须实现析构函数，否则派生类无法继承，也无法编译通过**。



#### **5、如果析构函数不是虚函数，一定会出现内存泄露吗？**

我觉得不一定。析构函数是虚函数的主要原因是，如果不是虚函数，每次结束时因为是父类指针所以只会调用父类的析构函数，而不会调用子类的析构函数，如果子类中有指针开辟空间，子类没有调用析构函数释放这个空间，就会导致内存泄露。但是如果子类中没有用指针开辟空间，都是普通的变量，应该就不会出现内存泄漏。（仅个人理解，如有不对的地方还请大佬指正）

**定义一个A\* pa= new A[5]; delete pa; 类A的构造函数和析构函数分别执行了几次？**

构造函数执行了5次，每new一个对象都会调用一个构造函数，析构函数只调用一次，如果调用delete[] pa 析构函数才会调用5次。（可以自行验证）



#### **6、指针和引用的区别是什么？**

（1） 引用必须定义时**初始化**，不能像指针一样仅int *a;这样定义，必须int & b=a;

（2） int & const r = a;这样写错误，因为引用本身就不能改变指向，**添加const多此一举。**

（3） 指针可以有多级**但引用只能有一级**。有int ** ,但是int &&并不代表引用的引用，而代表右值引用(看后面)。

	（ps：在某些时候&&也可以表示取数据原类型，`std::forward()`方法产生疑惑，可能是因为我们看到了函数头中的`F&& f`和`Args&&... args`，这难道不已经指明这个函数接收的参数类型应为右值引用吗？**其实不然。**这里的`F&& f`和`Args&&... args`中的`&&`并非是右值引用意思，而是一种特殊现象，这个现象被称作**万能引用**（universal reference）。

（4） 指针的++，--代表下一个数据，**引用的++，--代表数据本身的加减**。

（5）sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；

（6）当指针和引用作为函数参数的时候，指针传递参数会生成一个临时变量，引用传递的参数不会生成一个临时变量。

指针传递的本质是值传递复制实参的地址到函数的栈中，然后在形参中对地址取值操作。而引用的形参是给实参起了一个别名，可以直接操控形参从而实现对实参的控制。、

参考链接：[C++ 值传递、指针传递、引用传递详解](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/dingxiaoqiang/p/8012578.html)

题外话：

引用的本质就是指针，它的出现是为了书写方便，不要动不动有*，int a=10;

```cpp
int &b=a; //这里&a,&b取址相同，并不代表引用b不占用内存，而是系统自动将&b转换成对b中内容的读取。而b里面保存的是a的地址。后台实际运行时int *b=&a; b=12就是*b=12。
```



#### **7、用过哪些标准模板库（STL）？**

String类，迭代器，vector, deque, list, map, set,unordered_map等。



#### **8、背一下C++的容器，然后让你自己挑一个最熟的来讲。 选了vector，讲一下vector的扩容机制，其他的的实现原理，内存是怎么分配的。**

容器vector, deque, list, map, set等。

Vector扩容就是重新申请一段更长的连续内存空间并把以前的数据移动过去，释放以前的内存空间。以前的迭代器都会失效。一般用VS扩容都是扩容现有容器容量的2倍，有的是1.5倍。(g++默认为2)

**vector**

优点：

1.动态数组，当空间大小不够时，可以自动扩增，每次扩增大小为原来的2倍或者1.5倍。

2.查询效率很高。

缺点：

1.扩增空间的时候需要重新指向一个连续的内存空间，效率低。

2.插入删除需要移动元素，效率低（尾插时候不需要）。

注意：删除容器中数据的时候，缓冲区大小并不会改变，仅仅只是清除了其中的数据，只有在析构函数调用的时候vector才会自动释放缓冲区。

可以强制释放vector的缓冲区。

**reserve和resize的区别是什么？**

reserve只是开辟空间并不创建元素。而resize重新开辟空间并自动初始化元素。

reserve和resize的区别：

reserve是容器预留空间，但并不真正创建元素对象，在创建对象之前，不能引用容器内的元素，因此当加入新的元素时，需要用push_back()/insert()函数。

resize是改变容器的大小，并且创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。

再者，两个函数的形式是有区别的，reserve函数之后一个参数，即需要预留的容器的空间；resize函数可以有两个参数，第一个参数是容器新的大小，第二个参数是要加入容器中的新元素，如果这个参数被省略，那么就调用元素对象的默认构造函数。


**vector内部实现？**

Vector是一个类，它里面有三个指针myfirst,mylast,myend.分别表示首地址，元素容量地址，容器容量地址。通过这三个指针分别表示容器的所有操作。



**什么是迭代器失效？**

就是比如vector容器扩容的时候，释放了原来的内存空间，导致原来的迭代器都失效不能用了。

迭代器失效就是因为扩容，删除元素等缘故，导致原先容器的空间变化，进而导致迭代器（begin()和end()）发生了变化，从而失效。

```
 对于序列式容器，比如vector，删除当前的iterator会使后面所有元素的iterator都失效。这是因为顺序容器内存是连续分配（分配一个数组作为内存），删除一个元素导致后面所有的元素会向前移动一个位置。（删除了一个元素，该元素后面的所有元素都要挪位置，所以，iter++，已经指向的是未知内存）。
 对于关联容器(如map, set,multimap,multiset)，删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响。erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。
 数组型数据结构：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(*iter)(或erase(*iter))，然后在iter++，是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter);

链表型数据结构：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).

树形数据结构： 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。
```

**vector.push_back()一个值，内部发生什么？**

如果容量充足，就会在容器末尾添加该元素，如果容量不足，就会自动扩容，扩容的时候会重新寻找一个更大的连续内存，原来的迭代器会失效。扩容一般会扩大现有容器量的2倍。



**deque:（由一段一段定量的连续空间构成）**

deque 的最大任务就是在这些分段的连续空间上，维护其整体连续的假象，并提供随机存取的接口。deque为了维持整体连续的假象，设计一个中控器，其用来记录deque内部每一段连续空间的地址。大体上可以理解为deque中的每一段连续空间分布在内存的不连续空间上，然后用一个所谓的map作为主控，记录每一段内存空间的入口，从而做到整体连续的假象。

优点：

1.动态数组，一旦需要扩容，就是在首尾配置一段定量连续空间。

2.可以双端插入删除。d1.push_back(5); d1.push_front(-5);

3.查询效率高。

缺点：1.不适合中间删除插入。

2.占用内存多。（暂时不太清楚原因！）



**list：**（由双向链表（doubly linked list）实现而成）

优点：

1.任意地方都可以插入删除，插入删除效率高。

缺点：

1.随机访问效率差。

2.没有空间预留习惯，所以每分配一个元素都会从内存中分配。



**set：（由红黑树实现）**

优点：

1.可以自动排序。

2不需要做内存拷贝，插入删除效率高。

3.方便查找。

缺点：

1.插入删除时为了在二叉树上找到合适位置，会影响效率。



**map:（由红黑树实现）**

优点：

1.插入删除效率高。

2.扩容不会影响其他元素。

3.key值会自动排序。

缺点：

1.每次插入值的时候，都需要调整红黑树，效率有一定影响。

参考链接：这篇文章对STL介绍的非常详细，需要多看几遍：[STL详解]([luckyum：[C++ STL\] 各容器简单介绍](https://zhuanlan.zhihu.com/p/130905242))

```
关联式容器又分为set(集合)和map(映射表)两大类，以及这两大类的衍生体multiset(多键集合)和multimap(多键映射表)，这些容器均以RB-tree（red-black tree, 红黑树）完成。
此外，还有第3类关联式容器，如hashtable(散列表)，以及以hashtable为底层机制完成的hash_set(散列集合)/hash_map(散列映射表)/hash_multiset(散列多键集合)/hash_multimap(散列多键映射表)。也就是说，set/map/multiset/multimap都内含一个RB-tree，而hash_set/hash_map/hash_multiset/hash_multimap都内含一个hashtable。

set/map/multiset/multimap

set，同map一样，所有元素都会根据元素的键值自动被排序，因为set/map两者的所有各种操作，都只是转而调用RB-tree的操作行为，不过，值得注意的是，两者都不允许两个元素有相同的键值。

不同的是：set的元素不像map那样可以同时拥有实值(value)和键值(key)，set元素的键值就是实值，实值就是键值，而map的所有元素都是pair，同时拥有实值(value)和键值(key)，pair的第一个元素被视为键值，第二个元素被视为实值。

至于multiset/multimap，他们的特性及用法和set/map完全相同，唯一的差别就在于它们允许键值重复，即所有的插入操作基于RB-tree的insert_equal()而非insert_unique()。

hash_set/hash_map/hash_multiset/hash_multimap

hash_set/hash_map，两者的一切操作都是基于hashtable之上。不同的是，hash_set同set一样，同时拥有实值和键值，且实质就是键值，键值就是实值，而hash_map同map一样，每一个元素同时拥有一个实值(value)和一个键值(key)，所以其使用方式，和上面的map基本相同。但由于hash_set/hash_map都是基于hashtable之上，所以不具备自动排序功能。为什么？因为hashtable没有自动排序功能。

至于hash_multiset/hash_multimap的特性与上面的multiset/multimap完全相同，唯一的差别就是它们hash_multiset/hash_multimap的底层实现机制是hashtable（而multiset/multimap，上面说了，底层实现机制是RB-tree），所以它们的元素都不会被自动排序，不过也都允许键值重复。
```



#### **9、说一说Map的底层实现**

Map底层用红黑树。

红黑树是为了弥补二分查找树多次单边插入导致不平衡而引入的解决办法。

红黑树首先是一个平衡二叉树，满足根节点大于左子树小于右子树。

红黑树特点:

1. 根节点和叶子节点（都是空节点）都是黑色。
2. 每个红色节点的两个子节点都是黑色。
3. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

每次插入和删除都通过变色和旋转来保证红黑树符合上面的规则。



#### **10、为什么map底层要用红黑树实现而不用AVL实现**

平衡性方面（查找效率）， 插入节点方面，删除节点方面。

因为avl树是**高度平衡**，而红黑树通过增加节点颜色从而实现**部分平衡**，这就导致，插入节点两者都可以最多两次实现复衡，而删除节点，红黑树最多三次旋转即可实现复衡，旋转的量级是O（1），而avl树需要维护从被删除节点到根节点这几个节点的平衡，旋转的量级是O（logn）,所以红黑树效率更高，开销更小，**但是因为红黑树是非严格平衡，所以它的查找效率比avl树低。**

RB-Tree是功能、性能、空间开销的折中结果。

总结：实际应用中，若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。

简单来讲就是，对于存在大量插入删除操作，维护二叉平衡树的代价太高了，所以选取了一个相对平衡的红黑树作为替代。



**11、说一下你用过哪些C++11新特性！**

1. 右值引用，移动语义（移动构造函数），完美转发。

什么是右值引用？

**右值最大的特点就是无名且不需要存储空间。而一般等号或者return等使用的时候都需要不断的对对象进行复制导致占据大量的空间，而右值刚好解决了这个问题。**

分为右值和引用，引用就是给变量换一个名字，它的底层仍然是指针，只不过经过包装没有取值符更加简洁方便，右值一般来说在等式右边的值就是右值，右值一般没有名字，没有地址。右值的引用的形式即int && a; 实际开发中我们可能需要对右值进行修改。

移动构造函数要解决地问题是：当使用深拷贝时，其中需要指针开辟非常多的空间，就会极大影响运行效率，这时通过避免不断拷贝，直接移植来解决问题。

完美转发：右值引用本来只能接收右值，但是C++规定，对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为“万能引用”）。这样就能保证接收参数时数值的属性不变。

而对于函数模板内部来说，形参既有名称又能寻址，因此它都是左值。那么如何才能将函数模板接收到的形参连同其左、右值属性，一起传递给被调用的函数呢？方法就是将内部函数的参数加上forward<T>(t)，这样就是是实现了完美转发。

2. 智能指针。

3. lambda 匿名函数。

   ```
   []()->{}
   ```

参考链接：[C语言中文网C++11的17-24章节](https://link.zhihu.com/?target=http%3A//c.biancheng.net/view/7829.html) 这几个章节多看几遍。



#### **12、智能指针有几种？分别介绍一下他们的底层实现？**

Share_ptr, unique_ptr, weak_ptr。

**它们三者有什么区别？**

shared_ptr,unique_ptr,weak_ptr。第一个实现原理是同一个内存空间每多一个指针指向就计数加1，如果计数变为0就释放内存空间。第二个是计数只能为1，第三个只能指向该内存空间而没有所有权。主要用于辅助第一个指针，防止出现互锁。Shared_ptr当用普通指针初始化的时候，只能使用一次普通指针。它还可以自定义释放函数。Unique_ptr没有拷贝构造函数。借助 weak_ptr 类型指针， 我们可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等。在构建 weak_ptr 指针对象时，可经常利用已有的 shared_ptr 指针为其初始化。

**智能指针的实现原理是什么？用到了什么技术？该技术有哪些特征？**

**RAII**是**Resource Acquisition Is Initialization**的缩写，意为“**资源获取即初始化**”。它是C++之父Bjarne Stroustrup提出的设计理念，其核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源。在RAII的指导下，C++把底层的资源管理问题提升到了对象生命周期管理的更高层次。用白话说就是：在类的构造函数中分配资源，在析构函数中释放资源。这样，当一个对象创建的时候，构造函数会自动地被调用，对象生命周期开始；而当这个对象被释放的时候，析构函数也会被自动调用，对象生命周期结束。于是乎，一个对象的生命期结束后将会不再占用资源，资源的使用是安全可靠的。

**智能指针使用RAII特性来实现自动GC**，本质就是利用RAII技术对普通指针进行封装，所以智能指针实质上是一个对象，行为表现的却像一个指针。实现原理比较简单：

- 智能指针将一个计数器与类指向的对象相关联，引用计数跟踪共有多少个类对象共享同一指针
- 每次创建类的新对象时，初始化指针并将引用计数置为1
- 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数
- 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；这是因为左侧的指针指向了右侧指针所指向的对象，因此右指针所指向的对象的引用计数加1
- 调用析构函数时，减少引用计数，如果引用计数减至0，则删除基础对象和引用计数对象

> std::shared_ptr是通过指针保持**对象共享所有权**的智能指针，多个shared_ptr对象可占有同一对象。下列情况之一出现时销毁对象并解分配其内存： 最后剩下的占有对象的shared_ptr被销毁 最后剩下的占有对象的shared_ptr被通过operator=或reset()赋值为另一指针 用delete表达式或在构造期间提供给shared_ptr的定制删除器销毁对象。
>
> std::weak_ptr是对被std::shared_ptr管理的对象存在非拥有性（“弱”）引用的智能指针，在访问所引用的对象前必须先转换为shared_ptr。 weak_ptr用来表达**临时所有权**的概念：当某个对象只有存在时才需要被访问，而且随时可能被他人删除时，可以使用它来跟踪该对象。需要获得临时所有权时，则将其转换为shared_ptr，此时如果原来的shared_ptr被销毁，则该对象的生命期将被延长至这个临时的shared_ptr同样被销毁为止。 weak_ptr的另一用法是打断shared_ptr所管理的对象组成的环状引用。若这种环被孤立（例如无指向环中的外部共享指针），则shared_ptr引用计数无法抵达零，而内存被泄露，能令环中的指针之一为弱指针以避免此情况。
>
> std::unique_ptr是通过指针**占有并管理另一对象**，并在unique_ptr离开作用域时释放该对象的智能指针。在下列两者之一发生时用关联的删除器释放对象： 销毁了管理的unique_ptr对象 通过operator=或reset()赋值另一指针给管理的unique_ptr对象 unique_ptr有两个版本：管理个对象（例如以new分配）和管理动态分配的对象数组（例如以new[]分配）
>
> - *shared_ptr和unique_ptr可以在构造时指定delete表达式，使用lambda表达式是较方便的做法*
> - shared_ptr和unique_ptr都重载了bool operator，所以可以直接通过if表达式判断其是否存储非空指针，不需要通过get()函数或者 *operator来判断*
> - shared_ptr通过引用计数来实现动态内存的自动释放，weak_ptr可以解决环状引用导致内存泄露的问题
> - *unique_ptr是可移动，不可复制的*
> - unique_ptr实现了数组类型的模板特化并提供了数组类型的deleter
> - *shared_ptr推荐使用模板函数std::make_shared进行构造，unique_ptr推荐使用模板函数std::make_unique进行构造。主要原因是其一make_shared可以减少一次堆内存分配，其二make_shared是异常安全的，更详细的解释参照stack overflow上的问答 [Difference in make_shared and normal shared_ptr in C++](https://gitee.com/link?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fstackoverflow.com%2Fquestions%2F20895648%2Fdifference-in-make-shared-and-normal-shared-ptr-in-c)*
> - C++11为shared_ptr提供了模板函数std::static_pointer_cast，std::dynamic_pointer_cast，std::const_pointer_cast和std::reinterpret_pointer_cast方便的进行智能指针类型的转换

**为什么需要智能指针？它在实际工程中有什么作用？**

为了防止内存泄漏，设置的自动回收机制。主要是为了防止内存泄漏，人总会出错。。。

**说一下shared_ptr的底层实现？**

引用计数，每多一个智能指向同一个内存，就把计数加1，当计数减到0的时候就释放该指针。当该指针作为形参传递的时候，计数会加1，当他出该函数时会自动减一。

**Weak_ptr的作用？**

获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等。另外防止循环引用。

**你刚才说到循环引用，那你口述一个循环引用的实例。**

比如说A、B两个类，两个类里面分别定义了一个对方类的智能指针，然后在主函数里面首先定义两个类的智能指针，然后分别把两个指针分别赋予对方的成员指针里，这样就形成了循环引用。

循环引用的问题是：一旦b出作用域，引用计数减一，导致b里面的a永远不会减一，导致a智能指针空间永远释放不掉，然后a出作用域时，a引用计数减一，a最终没释放，它里面的b也就不可能释放掉，最后a b都是1无法释放。

参考链接：[飞翔的猪：看完这篇，别再说不会智能指针了](https://zhuanlan.zhihu.com/p/141340361)（背一下这个链接里面的循环引用）

**在你说的这个实例中，那你怎么用weak_ptr来解决呢？**

把两个类里的智能指针定义为weak_ptr指针，这样第二次赋值的时候引用计数就不会加1，这样两个就不会相互影响了。

**智能指针和普通new指针有什么区别？**

主要是在作用范围上的区别。

任何情况下尽量不要使用new，而优先使用智能指针，因为new调用时作用范围也是局部的，不能跳出，几乎和普通指针没有什么区别，除非借用函数返回，而智能指针是真正实现了可以让指针全局读取的。

unique_ptr可以采用std::move()获取另外一个unique_ptr指针，然后右边的unique_ptr会失效



#### **13、说一下lambda表达式的底层实现（这个暂时保留）**

## **声明Lambda表达式**

Lambda表达式完整的声明格式如下：

```
[capture list] (params list) mutable exception-> return type { function body }
```

各项具体含义如下

1. capture list：捕获外部变量列表
2. params list：形参列表
3. mutable指示符：用来说用是否可以修改捕获的变量
4. exception：异常设定
5. return type：返回类型
6. function body：函数体

此外，我们还可以省略其中的某些成分来声明“不完整”的Lambda表达式，常见的有以下几种：

| 序号 | 格式                                                        |
| ---- | ----------------------------------------------------------- |
| 1    | [capture list] (params list) -> return type {function body} |
| 2    | [capture list] (params list) {function body}                |
| 3    | [capture list] {function body}                              |

其中：

- 格式1声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。
- 格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型： （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。
- 格式3中省略了参数列表，类似普通函数中的无参函数。

先只会用：sort(num, num+4,[=](int x,int y)->bool{**return** x < y;});

[]代表传递方式，值传递还是引用传递等。

()括号里是传递的参数

->bool：指明函数返回类型。

{}函数体。

另外：

有时候值传递需要在函数内部修改参数，需要加mutable

可以通过noexcept/throw()限制函数体中是否可以抛出异常。



#### **14、C++中三种权限的区别？**

Public:可以被任意成员函数访问。

Protect:可以被本类或者派生类类成员函数访问。

Private:只能被本类成员函数访问。（如果是虚函数，即使声明为private也会被派生类访问）



#### **15、static关键字，静态成员变量和函数系列：**

**static变量是什么时候初始化的？**

但在C和C++中静态局部变量的初始化节点又有点不太一样。

在C中，初始化发生在代码执行之前，**编译阶段分配好内存之后，就会进行初始化**，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。

而在C++中，**初始化时在执行相关代码时才会进行初始化**，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所*C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的。

**静态成员变量：**

作用：使用静态成员变量**来实现多个对象共享数据的目标**。一个类中可以有一个或多个静态成员变量，**所有的对象都共享这些静态成员变量**，都可以引用它。静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。

特点：

1.static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。具体来说，static 成员变量和普通的 static 变量类似，都在**内存分区中的全局数据区分配内存。**

2.static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是**在（类外）初始化时分配**。反过来说，没有在类外初始化的 static 成员变量不能使用。**初始化的时候不能再加static。只能在声明的时候加上。**

3.**静态成员变量必须初始化，而且只能在类体外进行**。例如：

int Student::m_total = 10;初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。

4.**静态全局变量只能作用在本文件中，不能跨文件**。静态局部变量只能作用于该局部函数中，虽然函数结束后该变量还存在，但是不能再调用。静态局部变量多用于循环调用某个函数时使用。



**静态成员函数有些特性？**

可以说静态成员函数的出现就是**为了处理静态成员变量的**。静态成员变量。static成员变量属于类（被存放在全局区中），不属于某个具体的对象（具体对象的内存是分配在堆中的），即使创建多个对象，也只为该变量分配一次内存，所有对象使用的都是这份内存中的数据。

静态成员函数与普通成员函数的根本区别在于：**普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（**包括静态成员变量和静态成员函数）另外相比普通成员函数，不管有没有创建对象，主函数都可以调用静态成员函数。

**（1）静态成员函数只能访问静态成员变量。只能去调用其他静态成员函数。**

**（2）相比普通成员函数，不管有没有创建对象，主函数都可以调用静态成员函数。**



**静态成员函数可以设置为virtual吗？为什么？**

1. static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。

2. 静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有this指针。

虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.

对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual。



#### **16、const关键字， 常量指针和指针常量，顶层const和底层const分别是什么？**

const的作用：被它修饰的值不能改变，是只读变量。必须在定义的时候就给它赋初值。

const int a=10; //a的值不能改变了或者写成 int const a=10;也是一样的。

参考链接：[const关键字及其作用（用法），C语言const详解](https://link.zhihu.com/?target=http%3A//c.biancheng.net/view/217.html)

**常量指针（底层const）：**

形式：const 数据类型 *指针变量=变量名 或者 数据类型 const *指针变量=变量名

比如： int temp=10; const int* a=&temp；或者int const *a=&temp；

特点：指针指向的值被指针限定住，不能**通过指针改变指向的值**了。比如 *a=9;这是错误的。但是可以不通过指针改变指向的值，比如 可以直接temp=9; 而不*a=9；另外指针也可以指向其他地址，比如 int b=0; const int* a=&b；

**指针常量（顶层const）：**

形式： 数据类型 * const 指针变量=变量名

比如：int temp=10, temp1=12; int* const p=&temp;

特点：**指针的指向的地址不能改变。并且**声明时必须初始化。比如: p=&temp2;错误。但是该地址的内容可以修改，比如 *p=9；

**常指针常量：**

形式：const 数据类型 * const 指针变量=变量名； 或者 数据类型 const *const 指针变量=变量名；

比如：int temp=10; const int* const p=&temp;

特点：上述两者的综合，既不能通过指针改变指向的值，指针的指向的地址也不能改变。

**区分顶层const和底层const的原因？**

1.底层const的指针不能赋给非底层const。

2.强制类型转换函数const_cast只能将底层const指针改变为普通指针，其余指针不行。

参考链接：[C++的顶层const和底层const的理解_冬之晓-CSDN博客_顶层const](https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_19528953/article/details/50922303)

**volatile关键字（暂时问的不多）**

和 const 对应，遇到这个关键字声明的变量，编译器对**访问该变量的代码就不再进行优化**，从而可以提供对特殊地址的稳定访问。

在多线程中，当两个线程都要用到某一个变量且该变量的值会被改变时，应该用 volatile 声明，该关键字的作用是防止优化编译器把变量从内存装入 CPU 寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile 的意思是**让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。**

```cpp
volatile int i=10;
int a = i;
...
// 其他代码，并未明确告诉编译器，对 i 进行过操作
int b = i;
```

volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。



#### **17、你vector扩容后，在拷贝元素时有哪几种拷贝方式？**

v是已经定义了的vector类型

（1）vector<int> v2(v);

（2）vector<int>v2;

v2.assign(v.begin(),v.end());//assign代表用新元素替换原有内容。

（3）vector<int> v2;

v2.swap(v);//swap代表交换两个容器的所有元素

（4）vector<int>v1;//这个和v没关了

vector<int> v2;

v2.push_back(2);

v2.push_back(2);

v1.insert(v1.end(), v2.begin(), v2.end());//将v2中的数据，全部插入到v1的末尾。相当于复制了一份数据。

#### **18、说一下C++模板？**

template <typename T>和template <class T>是完全一样的。

**（1）模板函数的语法：**

```cpp
template <typename 类型参数1 , typename 类型参数2 , ...> 返回值类型  函数名(形参列表){
    //在函数体中可以使用类型参数
}
```

例子：

```cpp
template<typename T> 
void Swap(T &a, T &b){
    T temp = a;
    a = b;
    b = temp;
}
```

**（2）类模板的语法：**

```cpp
template<typename 类型参数1 , typename 类型参数2 , …> 
class 类名{
    //TODO:
};
```

例子：

```cpp
template<typename T1, typename T2>  //这里不能有分号
class Point{
public:
    Point(T1 x, T2 y): m_x(x), m_y(y){ }
public:
    T1 getX() const;  //获取x坐标
    void setX(T1 x);  //设置x坐标
    T2 getY() const;  //获取y坐标
    void setY(T2 y);  //设置y坐标
private:
    T1 m_x;  //x坐标
    T2 m_y;  //y坐标
};
```

上面的代码仅仅是类的声明，我们还需要在类外定义成员函数。在类外定义成员函数时仍然需要带上模板头，格式为：

注意相对于函数模板，在返回值类型和函数名之间多了**类名**<类型参数1, 类型参数2,...>::

```cpp
template<typename 类型参数1 , typename 类型参数2 , …>
返回值类型 类名<类型参数1 , 类型参数2, ...>::函数名(形参列表){
    //TODO:
}
```

例子如下：

```text
template<typename T1, typename T2>  //模板头
T1 Point<T1, T2>::getX() const /*函数头*/ {
    return m_x;
}
template<typename T1, typename T2>
void Point<T1, T2>::setX(T1 x){//必须在类名后添加<T1,T2>
    m_x = x;
}
template<typename T1, typename T2>
T2 Point<T1, T2>::getY() const{
    return m_y;
}
template<typename T1, typename T2>
void Point<T1, T2>::setY(T2 y){
    m_y = y;
}
```

之后就是使用类模板创建对象。这里不细说了。

**（3）C++模板的由来：**

C++ 模板也是被迫推出的，最直接的动力来源于对[数据结构](https://link.zhihu.com/?target=http%3A//c.biancheng.net/data_structure/)的封装。数据结构关注的是数据的存储，以及存储后如何进行增加、删除、修改和查询操作，它是一门基础性的学科，在实际开发中有着非常广泛的应用。**C++ 开发者们希望为线性表、链表、图、树等常见的数据结构都定义一个类，并把它们加入到标准库中，这样以后程序员就不用重复造轮子了，直接拿来使用即可。**

但是这个时候遇到了一个无法解决的问题，就是数据结构中每份数据的类型无法提前预测。以链表为例，它的每个节点可以用来存储小数、整数、字符串等，也可以用来存储一名学生、教师、司机等，还可以直接存储二进制数据，这些都是可以的，没有任何限制。而 C++ 又是强类型的，数据的种类受到了严格的限制，这种矛盾是无法调和的。

要想解决这个问题，C++ 必须推陈出新，跳出现有规则的限制，开发新的技术，于是模板就诞生了。模板虽然不是 C++ 的首创，但是却在 C++ 中大放异彩，后来也被 Java、C# 等其他强类型语言采用。

**整个标准库几乎都是使用模板来开发的。**

**（4）函数模板重载**

上述函数模板不能解决所有问题，比如交换两个数组，此时就需要对函数模板进行改动，以符合自身的要求。重载的函数模板如下：

```cpp
template< typename T> 
void Swap(T a[], T b[], int len){
   T temp;
   for(int i=0; i<len; i++){
       temp = a[i];
       a[i] = b[i];
       b[i] = temp;
   }
 }
```

参考链接：[C++函数模板5分钟入门教程](https://link.zhihu.com/?target=http%3A//c.biancheng.net/view/2317.html) 7.1-7.4节好好看一看
其余函数模板的实参推断，显式具体化，非类型参数等，后续用到再具体探讨。



#### **19、说一下深浅拷贝**

当类持有动态分配的内存、指向其他数据的指针等的时候，需要深拷贝，保证拷贝的类里的指针指向自己的空间。这样做的结果是，原有对象和新对象所持有的动态内存是相互独立的，更改一个对象的数据不会影响另外一个对象。

参考链接：[C++深拷贝和浅拷贝（深复制和浅复制）完全攻略](https://link.zhihu.com/?target=http%3A//c.biancheng.net/view/2336.html)

拷贝构造函数了解过吗？属于深拷贝还是浅拷贝？

如果只是简单的数据复制就是浅拷贝，如果需要开辟新的空间，或者复制类的时候提前需要做一些准备，就需要深拷贝。

指针开辟空间的深拷贝：[C++深拷贝与浅拷贝的区别 （简单易懂版）](https://link.zhihu.com/?target=https%3A//blog.csdn.net/joshgu958/article/details/35302413)

其实简单理解就是，浅拷贝传递的是引用，即两个对象指向同一片地址空间，任何一个对象修改数据都会导致另外一个对象中的数据也被改写，深拷贝就是新对象新开一片内存区域，将原对象中的元素值复制一遍到新的地址空间内，然后两者分别维护各自的内存空间区域。



#### **20、什么是抽象类？**

包含纯虚函数的类称为抽象类。如果派生类继承了抽象类但是没有实现所有抽象方法，那么派生类也是抽象类

**子类实现抽象类有哪些注意事项？**

必须把基类中的所有纯虚函数都初始化实例化。子类的函数名必须和抽象类一样，参数类型也要一模一样。

**那基类的所有纯虚函数都要实现吗？**

对，所有的都要实现。

**抽象类存在的意义，要解决什么问题？**

在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。

在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现（谁派生谁实现）。这部分未完成的功能，往往是基类不需要的，或者在基类中无法实现的。虽然抽象基类没有完成，但是却强制要求派生类完成，这就是抽象基类的“霸王条款”。



#### 21、 **c++的空类会默认生成哪几个成员函数？**

对于空类，编译器不会生成任何的成员函数，只会生成1个字节的占位符。

有时可能会以为编译器会为空类生成默认构造函数等，事实上是不会的，编译器只会在需要的时候生成6个成员函数：一个缺省的构造函数、一个拷贝构造函数、一个析构函数、一个赋值运算符、一对取址运算符和一个this指针。

class Empty

{

public:

Empty(); // 缺省构造函数

Empty( const Empty& ); // 拷贝构造函数

~Empty(); // 析构函数

Empty& operator=( const Empty& ); // 赋值运算符

Empty* operator&(); // 取址运算符

const Empty* operator&() const; // 取址运算符 const

};

默认构造函数

析构函数

拷贝构造函数

赋值运算符（operator=）

取址运算符（operator&）（一对，一个非const的，一个const的）

参考链接：[C++空类编译器自动生成的6个成员函数_乌托邦-CSDN博客](https://link.zhihu.com/?target=https%3A//blog.csdn.net/taiyang1987912/article/details/43485569)



#### **22、 （拷贝）赋值函数是什么？**

赋值函数主要是通过等号给另一个类初始化赋值。函数样子如下：

注意返回值和参数。

![img](https://pic3.zhimg.com/80/v2-f8bbacfbf03b544a3c3b89e394113bb2_720w.jpg)

[c++中的赋值函数_灰猫-CSDN博客](https://link.zhihu.com/?target=https%3A//blog.csdn.net/weixin_43919932/article/details/88730884)



**赋值函数和拷贝构造函数的区别？**

拷贝构造函数：用基于同一类的一个对象构造和**初始化另一个对象**。

```cpp
Example(const Example &);//构造拷贝函数，深拷贝，会调用构造函数
Example(Example &&);//移动构造函数，浅拷贝
//非 const 右值引用只能操作右值，程序执行结果中产生的临时对象（例如函数返回值、lambda 表达式等）既无名称也无法获取其存储地址，所以属于右值。当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。
```

赋值函数：当一个类的对象向该类的另一个对象赋值时，就会用到该类的赋值函数。

1）赋值函数的前提是两个类都已经存在的前提下，而拷贝构造函数一般是用来初始化类对象的是偶调用，此时被拷贝的对象前提并不存在。



2）一般来说在数据成员包含指针对象的时候，需要考虑两种不同的处理需求：**一种是复制指针对象，另一种是引用指针对象。**拷贝构造函数大多数情况下是复制，而赋值函数是引用对象。



3）实现不一样。拷贝构造函数首先是一个构造函数，它调用时候是通过参数的对象初始化产生一个对象。赋值函数则是把一个新的对象赋值给一个原有的对象，所以如果原来的对象中有内存分配要先把内存释放掉，而且还要检察一下两个对象是不是同一个对象，如果是，不做任何操作，直接返回。（这些要点会在下面的String实现代码中体现）



参考链接：[C++中构造函数，拷贝构造函数和赋值函数的区别和实现_ZMyths的博客-CSDN博客_赋值构造函数](https://link.zhihu.com/?target=https%3A//blog.csdn.net/zcyzsy/article/details/52132936)



#### **23、 写时拷贝(COW Copy-On-Write)有了解过吗？**

和移动语义很像，都为了解决深拷贝带来的问题，移动语义是为了解决深拷贝时多次拷贝导致多次开辟空间降低运行效率产生的，而写时拷贝是读取的时候不会进行深拷贝，只有你写的时候才会拷贝，是拖延版深拷贝。String类里面就有所运用。不深拷贝仅仅让多个指针指向同一个空间，然后每次进行计数。

简单理解就是，如果对不对数据进行任何操作，只是简单的读取，那么不会创建新的数据，节省时间和空间开销，但是一旦某一个对象要修改数据，那么此时必须重新拷贝一个新的数据对象来进行操作，即延迟写。

具体可参考这个：[C/C++ - 写时拷贝_阿亮的博客-CSDN博客](https://link.zhihu.com/?target=https%3A//blog.csdn.net/Dawn_sf/article/details/66522352)



#### **24、什么情况下必须使用初始化列表初始化数据成员？**

（1）需要初始化**const修饰的类成员**或初始化**引用成员**数据；

（2）需要初始化的数据成员是对象的情况，并且这个对象只有含参数的构造函数，没有无参数的构造函数；

（3）子类初始化父类的私有成员；

参考链接：[C++必须使用【初始化列表】初始化数据成员的三种情况_小凡的专栏-CSDN博客_成员初始化列表](https://link.zhihu.com/?target=https%3A//blog.csdn.net/sinat_20265495/article/details/53670644)



#### **25、内存是怎样分配的？**

**按区分：代码区、全局/静态区、常量区、堆栈区**

代码区：存放程序的代码，即CPU执行的机器指令，一般只读。

静态区（全局区）：存放静态变量和全局变量。

常量区：存放常量(程序在运行的期间不能够被改变的量，例如: 10，字符串常量”abcde”， 数组的名字等)

堆区：由程序员调用malloc()函数来主动申请的，需使用free()函数来释放内存。

栈区：存放函数内的局部变量，形参和函数返回值。

**申请后系统的响应** 

- 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。（常见的栈溢出异常即死递归）
- 堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

**申请大小的限制**

- 栈：在Windows下,栈是向低地址扩展，从上到下生长的扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。
- 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

**申请效率的比较** 

- 栈：由系统自动分配，速度较快。但程序员是无法控制的。
- 堆：由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.



修改：

下面的分法并不是网上所说的内存分配，而是二进制ELF文件链接和执行时文件内的分法。

ELF 是Executable and Linking Format的缩写，即可执行和可链接的格式。

链接视图是以节（section）为单位，执行视图是以段（segment）为单位。

汇编器链接成二进制ELF文件后，分配出.text、.data、.rodata、.bss等



(.text)：存放程序执行代码，一般是只读。

(.data)：存放已初始化的全局变量和局部静态变量（static），可读可写，属于静态内存分配。

(.rodata)：存放的是只读数据，主要是一些const变量和字符串常量。

.bss：存放未初始化的全局变量和局部静态变量（static），属于静态内存分配。

堆：用于存放进程运行中被动态分配的内存段。

栈：存放程序临时创建的局部变量，形参和函数返回值等。

这里参考链接：[ELF文件解析（一）：Segment和Section - JollyWing - 博客园](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/jiqingwu/p/elf_format_research_01.html)



#### **26、new和malloc有什么区别?（问的超级多，cvte最深入问到内存池的设计（类似于Linux内存池机制））**

|        特征        |              new/delete               |             malloc/free              |
| :----------------: | :-----------------------------------: | :----------------------------------: |
|   分配内存的位置   |              自由存储区               |                  堆                  |
| 内存分配成功返回值 |             完整类型指针              |                void*                 |
| 内存分配失败返回值 |             默认抛出异常              |               返回NULL               |
|   分配内存的大小   |       由编译器根据类型计算得出        |          必须显式指定字节数          |
|      处理数组      |       有处理数组的new版本new[]        | 需要用户计算数组的大小后进行内存分配 |
|  已分配内存的扩充  |            无法直观地处理             |         使用realloc简单完成          |
|    是否相互调用    | 可以，看具体的operator new/delete实现 |             不可调用new              |
| 分配内存时内存不足 | 客户能够指定处理函数或重新制定分配器  |       无法通过用户代码进行处理       |
|      函数重载      |                 允许                  |                不允许                |
| 构造函数与析构函数 |                 调用                  |                不调用                |

**使用new操作符来分配对象内存时会经历三个步骤：**

- 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。
- 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。
- 第三部：对象构造完成后，返回一个指向该对象的指针。

**自由存储区是否等价于堆（或者说两者有什么区别）？**

- 自由存储是C++中通过new与delete动态分配和释放对象的**抽象概念**，而堆（heap）是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。
- new所申请的内存区域在C++中称为自由存储区。藉由堆实现的自由存储，可以说new所申请的内存区域在堆上。
- 堆与自由存储区还是有区别的，它们并非等价。

**new operator和operator new的区别？**

new operator是c++内建的，无法改变其行为；而operator new 是可以根据自己的内存分配策略去重载的。

new就是new operator，调用new的时候编译器做了三件事，

1.是用operator new( )分配内存，

2.是调用构造函数（就是你new的类类型或者string等类型的构造函数）。

3.返回相应的指针。

new的底层是调用operator new( )分配内存的。该函数调用malloc申请内存。

operator new 可以进行重载，但是需要注意的是：

```
（1） 只分配所要求的空间，不调用相关对象的构造函数。当无法满足所要求分配的空间时，
则如果有new_handler，则调用new_handler；否则如果没要求不抛出异常（以nothrow参数表达），
则执行bad_alloc异常；否则返回0。
（这个调用顺序要记住，可以通过set_new_handler()函数设置new_handler）

（2） 重载时，返回类型必须声明为void*

（3） 重载时，第一个参数类型必须为表达要求分配空间的大小（字节），类型为size_t

（4） 重载时，可以带其它参数。
当然重载了operator new，你就要重载对应的operator delete。

operator new实际上总是以标准的C malloc()完成，虽然并没有规定非得这么做不可。
```

此外还有定位new表达式

类似于constructor成员，有第三种new表达式，称为定位n**ew(placement new)**。定位new表达式在已分配的与原始内存中初始化一个对象，他与new的其他版本不同，**它不分配内存**。相反，**它接受指向已分配好但未构造的内存指针，并在该内存中初始化一个对象**。实际上，定位new表达式使我们在特定的、预分配的内存地址构造一个对象。它可以定义类的任何构造函数。

```cpp
new(place_address) type

new(place_address) type(initializer_list)
//place_address必须是一个指针，而initializer_list提供了初始化列表（可能是空的），以便在构造新分配的对象中使用。
```

```
1. 使用注意点
   如果只考虑分配和释放，内存管理基本要求是“不重不漏”：既不重复 delete，也不漏掉 delete。也就说我们常说的 new/delete 要配对，“配对”不仅是个数相等，还隐含了 new 和 delete 的调用本身要匹配，不要“东家借的东西西家还”。例如：

（1）用系统默认的 malloc() 分配的内存要交给系统默认的 free() 去释放；

（2）用系统默认的 new 表达式创建的对象要交给系统默认的 delete 表达式去析构并释放；

（3） 用系统默认的 new[] 表达式创建的对象要交给系统默认的 delete[] 表达式去析构并释放；

（4） 用系统默认的 ::operator new() 分配的的内存要交给系统默认的 ::operator delete() 去释放；

（5） 用 placement new 创建的对象要用 placement delete （为了表述方便，姑且这么说吧）去析构（其实就是直接调用析构函数）；

（6）从某个内存池 A 分配的内存要还给这个内存池。
（7）如果定制new/delete，那么要按规矩来。见EffectiveC++相关条款。
```

#### **27、讲一下四种类型转换符？**

以前的强制类型转换是（类型），形式太过于常见容易与其他搞混，于是产生了一些标准的类型转换符。

格式：xxx_cast<newType>(data) newType 是要转换成的新类型，data 是被转换的数据。

**static_cast(data) ：**

（1）近似类型转换，如int转double,short转int,const转非const,向上转型等。

eg: int m=10; long n= static_cast<long>(m);

（2）void*指针和具体类型指针之间的转换，例如 void *转 int *、char *转 void *等。

eg:int *p1 = static_cast<int*>( malloc(10 * sizeof(int)) ); //malloc申请的是void*指针

（3）有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）。

**const_cast(data) ：**

用来将const/volatile 类型转换为非 const/volatile 类型。

eg: const int n = 100; int *p = const_cast<int*>(&n);

&n 用来获取 n 的地址，它的类型为 const int *，就是我们前面说的常量指针（回头翻翻），必须使用 const_cast 转换为 int *类型后才能赋值给 p。否则常量指针不能直接用指针改值。

**reinterpret_cast(data) ：**

可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如**两个具体类型指针之间的转换**、**int 和指针之间的转换。非常简单粗暴，但是风险很高。**

对于两个具体类型指针之间的转换，不同类型的数据存储格式不一样，长度也不一样，用 A 类型的指针指向 B 类型的数据后，会按照 A 类型的方式来处理数据：如果是读取操作，可能会得到一堆没有意义的值；如果是写入操作，可能会使 B 类型的数据遭到破坏，当再次以 B 类型的方式读取数据时会得到一堆没有意义的值；

对于int 和指针之间的转换，将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件。

**dynamic_cast(data) ：**

用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），就是把继承类指针转换为基类指针；也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功。（RTTI机制不了解可以去查一下）

参考链接：[C++ static_cast、dynamic_cast、const_cast和reinterpret_cast（四种类型转换运算符）](https://link.zhihu.com/?target=http%3A//c.biancheng.net/view/2343.html)

**你刚才说的转换构造函数或者类型转换函数讲一下？**

**转换构造函数：**

一般的类型转换如int*转换为float*,进行强制类型转换为，编译器内部就知道具体怎么转换，但是比如将一个整数转换为一个复数类，编译器就不知道了，需要我们手动写转换构造函数函数进行转换。这时候就需要转换构造函数帮我们转换。

转换构造函数的话，其实就是一个**带一个参数**的普通构造函数，但是这个函数自带的一个特点是，当主函数调用比如Complex c2 = c1 + 15.6时，这个构造函数会默认通过Complex（15.6）把本来是double类型的数转换为Complex类，然后两者就可以实现正常相加。更神奇的是Complex（）括号内除了double，还有int,char,bool(bool --> int --> double --> Complex)最后都能经过多次转换变成 Complex类。

还有一个神奇的事就是普通构造函数，两个参数的构造函数还有转换构造函数三者其实可以合并为一个构造函数，方法就是对参数使用默认参数Complex(double real = 0.0, double imag = 0.0): m_real(real), m_imag(imag){ }。

既是构造函数，又有转换能力，所以被叫做转换构造函数，最大的作用就是将其他类型转换为当前类型。

**类型转换函数：**

作用：就是将当前类的类型转换为其他类型。

非常简单，不用在函数前标注返回值（因为就是求返回值），不用参数（因为当前类类型就是参数），格式如下：

operator type(){ //TODO: return data;}

eg:operator double() const { return m_real; } //表示将当前类转化为double类

在现实情况中，两者一般不同时使用，否则会产生二义性，当两种转换同时可以使结果成立的时候，编译器不知道该使用哪个，现实中经常是只保留转换构造函数，而把类型转换函数变为类的成员函数来实现同样的作用。

参考链接：[C++转换构造函数：将其它类型转换为当前类的类型](https://link.zhihu.com/?target=http%3A//c.biancheng.net/view/2339.html)9.6 9.7 9.8



#### 28、重载、隐藏、重写（覆盖）三者的区别？（问的超级超级多！阿里，腾讯，cvte，虎牙都问过）**

**重载**：是指同一可访问区内被声明的几个**具有不同参数列**（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型（统一为void，否则报错）。

**隐藏**：是指**派生类**的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。（**和重载有些类似，但是注意派生类中函数只需要同名便会隐藏基类中的函数**）

**重写(覆盖)**：是**指派生类**中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

**重载的参数不同,函数体不同；隐藏的参数可以不同，函数体不同；重写或者覆盖仅仅函数体不同。**

重载根据名字可以猜测一定有重新的东西加进来；覆盖，根据这个名字就能联想到要一模一样才能覆盖。隐藏的话只要盖上就行，不一定非要一模一样。

**重载为什么改变参数就可以实现调用不同的函数？**

因为C++在编译的时候会对函数进行重命名，保证函数名的唯一性，而重载函数的参数不同，就会被命名为不同的函数名。



#### **29、C和C++的区别？**

**（1）C语言面向过程，不易扩展；C++面向对象，易扩展。**当然C语言也可以通过结构体加函数指针实现面向对象，但是设计复杂。

**面向过程**：面向过程编程就是分析出解决问题的步骤，然后把这些步骤一步一步的实现，使用的时候一个一个的依次调用就可以了。

**面向对象**：面向对象编程就是把问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。

**（2）关键字不同**

C99有32个关键字；C++98有63个关键字。struct、class、malloc 、new等关键字有些微小的区别。

**（3）返回值不同**

C语言中，如果一个函数没有指定返回值类型，默认返回int类型；C++中，如果一个函数没有返回值则必须指定为void。

**（4）参数列表**

在C语言中，函数没有指定参数列表时，默认可以接收任意多个参数；但在C++中，因为**严格的参数类型检测**，没有参数列表的函数，默认为 void，不接收任何参数。

C++缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的参。而C语言不支持缺省参数。

**（5）函数重载和引用**

C++可以进行函数重载和引用，而C不可以。

参考链接：[C语言和C++的区别与联系（详细）_cherrydreamsover的博客-CSDN博客_c语言和c++的区别和联系](https://link.zhihu.com/?target=https%3A//blog.csdn.net/cherrydreamsover/article/details/81835976)

其实C++扩展了很多东西，泛型编程，异常处理，命名空间，STL标准库等，就不一一列举，C语言可以实现的，C++几乎都可以实现。

#### 30、**构造函数可以被重载么？析构函数呢？**

构造函数可以被重载，因为构造函数可以有多个且可以带参数。（常见的为有参构造或者无参构造）

析构函数不可以被重载，因为析构函数只能有一个，且不能带参数。

构造函数主要用来在创建对象时完成对对象属性的一些初始化等操作, 当创建对象时, 对象会自动调用它的构造函数。一般来说, 构造函数有以下三个方面的作用:

1、给创建的对象建立一个标识符；

2、为对象数据成员开辟内存空间；

3、完成对象数据成员的初始化。

## c++关键字补充

```
noexcept//用于函数声明不会发生异常
explicit//禁止隐式类型转换
```

**0、inline和define的区别？**

define: 预编译时进行处理，只进行简单的替换，不能进行参数有效性检测及使用C++类的成员访问控制。

inline:内联函数对编译器提出建议，是否进行宏替换，编译器有权拒绝。它是个真正的函数，调用时有严格的参数检测；它也可作为类的成员函数。

区别

1. 内联函数在编译时展开，而宏是由预处理器对宏进行展开
2. 内联函数会检查参数类型，宏定义不检查函数参数 ，所以内联函数更安全。
3. 宏不是函数，而inline函数是函数
4. 宏在定义时要小心处理宏参数，（一般情况是把参数用括弧括起来）。

参考链接：[C++ inline 与#define 区别联系](https://link.zhihu.com/?target=https%3A//blog.csdn.net/shiyang6017/article/details/52893231%23%3A~%3Atext%3D%E5%8C%BA%E5%88%AB%20%E4%B8%80%E3%80%81define%E6%98%AF%20%E9%A2%84%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%84%E7%90%86%E7%9A%84%E5%AE%8F%3B%20%E5%8F%AA%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%97%E7%AC%A6%E6%9B%BF%E6%8D%A2%2C%E6%97%A0%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%EF%BC%8C%E8%80%8C%20inline%20%E6%98%AF%E7%BC%96%E8%AF%91%E6%97%B6%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9C%89%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%EF%BC%8C%E4%B8%94%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%89%E6%9D%83%E6%8B%92%E7%BB%9D%E5%86%85%E8%81%94%E3%80%82%20%E5%8C%BA%E5%88%AB%2C%E4%BA%8C%E3%80%81%20inline%20%E6%9C%89%E4%BC%A0%E5%8F%82%EF%BC%8C%E8%BF%99%E7%82%B9%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%80%E8%87%B4%20inline%20%E5%86%85%E8%81%94%E7%9A%84%E7%94%A8%E5%A4%84%20%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%9A%E5%8D%B3%E4%BB%A5%20inline%20%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BB%A3%E7%A0%81%E8%A2%AB%E6%8F%92%E5%85%A5%E8%B0%83%E7%94%A8%E8%80%85%E4%BB%A3%E7%A0%81%E5%A4%84%EF%BC%8C%E5%A6%82%E5%90%8CC%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84define%E3%80%82)



**1、说一下C++的RTTI机制？**

RTTI：Run Time Type Identification，即通过运行时类型识别。

比如运行时，要根据用户的输入选择父类指针的指向，输入小于100指针指向父类函数，大于等于100指向子类函数。

在 C++ 中，**只有类中包含了虚函数时才会启用 RTTI 机制**，其他所有情况都可以在编译阶段确定类型信息。

虽然名字比较奇怪，但是这个知识点总体还是比较简单，容易理解的。

参考链接：[C++ RTTI机制精讲（C++运行时类型识别机制）](https://link.zhihu.com/?target=http%3A//c.biancheng.net/view/vip_2302.html)



**2、C++中struct和class有什么区别？**

1.class默认成员都是private，而struct中默认成员都是public。

2.class的默认继承也是private，而struct中的默认继承都是public（原来struct也可以继承）。

3.class可以使用模板，而struct不行。

参考链接：[C++ class和struct到底有什么区别](https://link.zhihu.com/?target=http%3A//c.biancheng.net/view/2235.html)

另外，在C语言中，struct 只能包含成员变量，不能包含成员函数。而在C++中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。

**sizeof和strlen的区别？**

1. strlen 是函数，sizeof 是运算符。

2. strlen 测量的是字符的实际长度，以'\0' 结束。而sizeof 测量的是字符的分配大小。

比如int a=1;sizeof(a)==4而strlen(a)=1，再比如char a[30]="abcd"; sizeof(a)=30;而strlen(a)=4;

3. strlen函数求字符串实际长度，如果该字符串只定义没有赋值或者数组赋值中没有'\0'，所得结果都是错误不确定的。

4. sizeof可以用类型（如int,char等）做参数，strlen只能用char*做参数，且必须是以''\0''结尾的。
5. strlen的结果要在**运行的时候才能计算出来**，是用来计算字符串的长度，不是类型占内存的大小。而大部分编译程序**在编译的时候**就把sizeof计算过了，是类型或是变量的长度。

6. sizeof不能计算动态分配空间的大小。

```cpp
如：
char str[20] = "hello world";
   char *s = (char *)malloc(20);
   strcpy(s, str);
printf("sizeof(s)=%d\n",sizeof(s));//结果是4
```

参考链接：[关于 strlen 与 sizeof 的区别](https://link.zhihu.com/?target=https%3A//blog.csdn.net/zhengqijun_/article/details/51815081)



**3、class类的内存是怎样分布的？（频率很高）**

1.如果实例化一个空类，内存中只占用一个字节，作为标识。

2.包含成员变量，不包含成员函数是，根据**内存对齐原则**，将各个成员变量分布进内存。

3.就算包括成员函数，成员函数是不占用类的内存空间的，所以此时类的内存空间仍然和只包含成员变量的时候一样。而成员函数因为是公共的，一个类只有一份，一般根据编译器的不同保存在代码区或者只读区。

4.如果有虚函数的话，前四个字节会有一个虚函数表指针指向虚函数。（上一节面经有讲到），注意子类的虚函数表会先拷贝父类的表，然后替换和父类中一样函数的，最后补上子类自身的函数。

面试的时候问到多个子类，每个子类实例化都有一张虚函数表么？

是的，**多态中每个类都有一张虚函数表**。虚函数表编译时生成，一般放在二进制文件的.rdata Section, 还有说**存放在全局数据区（**这个还不太理解，希望有大神可以指点**）。**

参考链接：[C++类对象的内存分布 - zoux的博客](https://link.zhihu.com/?target=https%3A//zoux86.github.io/post/2019-12-04-c%2B%2B%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/)

[虚函数表存放在哪里 - chenhuan001 - 博客园](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/chenhuan001/p/6485233.html)

**当存在继承关系的时候，内存分布又是怎样的？**

父类和子类都有各自的内存空间。父类的内存空间就是它成员变量根据字节对齐占用的空间。而子类的空间注意了，首先要继承父类的空间，其次自己定义的变量放在父类空间的下面，如果子类定义了和父类同名的变量，调用的时候该变量会覆盖掉父类的变量，但是该变量的位置仍然是在父类空间的下面。另外通过添加类名的方式也可以调用权限为public的父类变量。

**C++多继承时存在什么风险？（小米）**

多继承时多个继承类中可能存在相同函数名导致继承混乱。

**你说成员函数不占类的内存空间，那具体是怎样访问成员函数的？类中的函数是如何调用的？用指针是如何偏移的？**

一般默认是内联函数，调用该函数的时候就会直接调用。如果涉及到递归之类的，就会像普通函数一样保存现场，然后跳转调用函数。

根据this指针访问成员函数，该指针会指向一个table表，表中保存着各个成员函数的地址。（**这个应该是错误的**，因为this指针一开始是指向实例化对象的内存起始地址，主要是用来作为参数传入函数内部进行成员变量的调用的）

具体的怎样调用，根据stack overflow上一些大神说，就是和普通函数调用是一样的。但是根据下面第一个链接的文章又说成员函数的调用是通过指针在一个table表里面调用的，所以有点懵。（这个有比较清楚的大佬希望可以指点一下）

**this指针存放在哪？**

当该非静态成员函数的参数个数一定时，它保存在CPU的EXC寄存器中，未定时（存在可变参数），保存在栈中。普通成员函数的函数地址在代码区。

**如果成员函数未使用任何成员变量的话，不管是不是static的，都能正常工作**

参考链接：[类（继承）的内存分配详解_路漫漫其修远-CSDN博客](https://link.zhihu.com/?target=https%3A//blog.csdn.net/vainlyhopelim/article/details/47754095)

[C++成员函数在内存中的存储方式_Hopefully Sky的博客-CSDN博客](https://link.zhihu.com/?target=https%3A//blog.csdn.net/fuzhongmin05/article/details/59112081)

```text
小感慨：面了几次，发现大厂几乎都是这种三连问，所以背八股文也要多询问自己几个问题。
```



**4、大端字节序和小端字节序解释一下？**

这里的大端小端，说的是从存储方面来看，按顺序低地址一般存储的高位（大端）还是低位（小端）。

大端字节序：就是说存储的时候，高位字节放在低地址，低位字节放在高地址。

小端字节序：存储的时候，刚好相反，高位字节放在高地址，低位字节放在低地址。

如下图

![img](https://pic4.zhimg.com/80/v2-89f8b69e0668cf14f01b7526ad2deebf_720w.jpg)

**计算机内部一般使用的是哪种？为什么？**

内部一般是小端字节序，计算机一般读取从低地址到高地址读取，把低位字节放在前面，先处理低位字节**效率更高**，因为CPU计算的时候都是先从低位开始的。

**大端**的**好处**是**网络通信的TCP/IP协议中字节序就是按照大端规定**的。 x86的cpu处理所有网络数据包时都要先将数字进行字节序反转才能进行运算，发送时也要先反转才能发送，增加了一点计算开销。

**如何判断是大端字节序还是小端字节序？**

最简单的判断方法就是，把1这个变量的地址拿出来存储成char变量，一般1的地址首位都是1，转变为char后只剩首位，然后检查这个首位低地址是1还是其他，如果是1的话，就说明地址的低位存储在低地址，所以是小端字节序，否则是大端字节序。

```text
void judge_bigend_littleend2()
{
    int i = 1;
    char c = (*(char*)&i);

    if (c)
        printf("小端\n");
    else
        printf("大端\n");
}
```

另外利用联合体共享内存空间的方法也可以进行判断。

**参考链接：**[大端 / 小端，三种判断方法_fl_sw的博客-CSDN博客_判断大端小端](https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_36391130/article/details/81944217)



**5、lambda表达式（匿名函数）的主要作用是什么？它的参数传递时内存是怎样布局的？**

产生原因：有些函数只会被调用一次，专门写一个函数不太划算，不写代码又比较紊乱，所以产生了匿名函数，也叫lambda表达式。它像一颗语法糖，它的所有功能普通函数都可以实现，有了它只是锦上添花。

这种函数式编程，函数的返回结果只与参数有关，与外面的一切全局变量等无关。

`lambda`表达式的大致原理：每当你定义一个`lambda`表达式后，编译器会自动生成一个匿名类（这个类当然重载了`()`运算符），我们称为闭包类型（closure type）。那么在运行时，这个`lambda`表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的`lambda`表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为`lambda`捕捉块。

匿名函数与普通函数的区别：

（1）省去定义的过程，代码变得更加简洁。

（2）省去了普通函数命名的过程。

lambda函数能实现较为简单的功能，**但不能传递数据，不能在表达式中使用for, if 等。**

**什么是捕获变量？**

**就是让匿名函数可以使用匿名函数外定义的变量**，但是匿名函数内使用的的函数外部变量，是外部变量的一个clone（C++11可以捕获引用，不是clone。OC语言中有__block，也可以直接改变外部变量的值），在匿名函数内修改外部变量不会影响到外部变量。C++中匿名函数既可以改变捕获的原值、又可以捕获克隆、又可以改变克隆值的值。

没有捕获行为的 lambda 表达式往往会被编译器优化成一个普通函数。

**lambda表达式捕获的变量保存在内存哪里？**

**暂时不知道。**

**匿名函数可以传入指针么？**

应该不可以。它传入的参数种类有下面几种：

1、空，没有使用任何函数对象参数。

2、=。按值传递，一般没有mutable关键字不能修改。因为默认函数是const。

3、&。引用传递方式

4、this。函数体内可以使用Lambda所在类中的成员变量.。

参考链接：[C++ lambda表达式与函数对象](https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/d686ad9de817)

**6、内存溢出和内存泄露有什么区别？**

内存溢出：是指申请内存时申请的空间不够，比如申请的int型的内存空间，但是存进去一个long型的数据。

内存泄露：是指申请内存空间之后，没有释放申请的内存空间。

内存溢出的原因：

（1）内存中加载的数据量过于庞大，比如一次性从数据库中读取大量数据。

（2）代码中出现死循环或者循环产生过多重复的实体。

（3）启动参数内存值设定的过小。

（4）使用的第三方软件的bug。

内存泄漏的原因：

（1）new创建出来的对象没有及时的delete掉，导致了内存的泄露；

（2）delete一个void*的指针可能会造成内存上的泄露！因为delete一个void*的对象指针，它不会调用析构函数，如果该对象里面有指针，最后指针就会没有释放导致内存泄漏。

delete一个void*为什么不会调用析构函数？（百度搜不到，求大神解答）



（3）new创建了一组对象数组，内存回收的时候却只调用了delete而非delete []来处理，导致只有对象数组的第一个对象的析构函数得到执行并回收了内存占用，数组的其他对象所占内存得不到回收，导致内存泄露；

**一般怎么处理内存泄漏？**

（1）从程序内部重新编译，养成良好的编码习惯，尽量在涉及内存的程序段，检测出内存泄漏。

（2）结束程序，内存自然就会被操作系统回收。

（3）重新启动电脑，立刻恢复。

**7、你C++用过什么设计模式？讲一讲。**

在设计日志系统的时候，用过单例模式。

我觉得没有比这个链接讲单例模式讲的更好的了：[shellmad-c++_44 单例模式的原理及实现_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1Gz4y1d7RJ%3Ffrom%3Dsearch%26seid%3D11312816026407113318)

我总结下：单例模式的目的就是，用户在调用该类的时候，只能使用建立一个该类对象。于是呢就把该类的构造函数给私有化了，这样外部就根本没办法直接实例化调用该类，只能类内部调用。这时候就在类内部创建一个公有化的函数，然后让该函数返回一个该类的指针，这样外部就可以通过这个函数调用该类了。但是问题是，调用该成员函数必须实例化一个该类对象，而现在已经不能实例化该类对象了，所以为了可以成功调用该函数，把该函数设置为静态函数，静态函数的作用范围是全局整个文件，这样外部就可以调用了。

但是这样的话实际上并不能保证主函数调用时该类对象指针的唯一性，因为该静态成员函数每次返回的都是一个新的new出来的值。每次都不一样。于是办法就是设置一个私有化的静态对象指针，在外部初始化这个指针为空。在静态成员函数中，如果该静态指针为空就创建对象指针，否则直接返回对象指针。这样就确保了在外部使用时，该对象的唯一性。

但是问题又来了，这样做可能会导致内存泄漏，因为你静态成员函数申请的指针并没有释放，还需要用户手动释放。改动的话就把该静态成员函数中的创建指针改为创建一个静态对象成员，然后返回该成员的地址。

但是返回一个地址就需要用指针去接收，用户就有可能对该指针进行delete造成错误，所以直接静态成员函数返回一个引用更好。这样delete就会无效。

又但是引用之后，主函数可以通过赋值号产生新的类对象。突破了唯一性的设定。所以现在又需要对拷贝构造函数进行私有化设置。或者直接对拷贝构造=delete，进行禁用。又或者把默认的运算符重载给禁用了。

代码如下：

```cpp
#include<iostream>
#include<stdlib.h>
#include<algorithm>
#include<vector>
#include<string>
using namespace std;

class Singleton{
public:
	~Singleton(){
	printf("~Singleton() destruct");
	}
	static Singleton& CreateObject()
	{
		static Singleton obj;
		return obj;
	}
	
	//Singleton(const Singleton& obj=delete;
private:
	Singleton(){
	printf("Singleton() Construct");
	}
	Singleton(Singleton& obj){
	printf("Singleton(Singleton& obj) Construct");
	}
};
int main(){
	Singleton& p0bj1=Singleton::CreateObject();

	return 0;
    }
```

**8、inline关键字讲一讲？**

引入的原因：为了解决一些**频繁调用的小函数**大量消耗栈空间（栈内存）的问题。因为每次调用函数都需要往栈中保存函数调用和返回地址，保存现场，太消耗内存。

使用注意：

1.函数内的代码必须简单，不能包含复杂的结构控制语句例如while、switch，并且函数本省不能直接递归调用。

2.inline函数仅仅是一个对编译器的建议，所以最后能否真正内联，取决于编译器。

3.最好将内联函数定义放在头文件中。

4.定义在类中的成员函数缺省都是内联的。（缺省就是默认的意思）

5.inline必须放在函数体的前面（也就是有函数实体），放在函数的声明处是无效的。

参考链接：[inline关键字的用法详解 - CTHON - 博客园](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/cthon/p/9152464.html)

**9、不合法的字符常量是哪些？（笔试的一些单选题）**

合法字符常量有两种：

普通字符：即用单撇号括起来的一个字符，如'b'，'y'，‘？’。如果里面有两个字符那就是错的。

转义字符：即特殊字符常量，其含义是将反斜杠后面的字符转换成另外的意义。一般只有两种\0nn代表八进制（0可以省略），n不能表示8或者大于8，\0xnn表示16进制，不能大于最大值“0x7f”，如'\xff'”不合法。

A. ‘\084’//不合法，八进制没有8。

B. ‘\x43’//合法。

C. ‘ab’ //不合法，字符只能是一个。

D. ‘\0’ //不合法，字符串不需要写结束符。

**10、讲一下STL中的特化和偏特化？**

参考链接：[C++ 模板，特化，与偏特化](https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/4be97bf7a3b9)

特化就是模板中变成了具体的类型，然后针对该类型的参数进行特殊的模板处理，比如一个比大小的函数，整数可以用等号判断是否相等，但是浮点数和double类型不能用等号进行判断，所以需要进行模板特殊化处理。

偏特化仍然是模板，不过是添加了一定的限制条件，比如把模板的类型换成指针类型。

**11、new operator和operator new的区别？**

new就是new operator，调用new的时候编译器做了三件事，

1.是用operator new( )分配内存，

2.是调用构造函数（就是你new的类类型或者string等类型的构造函数）。

3.返回相应的指针。

new的底层是调用operator new( )分配内存的。该函数调用malloc申请内存。

参考链接：[C++ operator new和new operator区别](https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_26079093/article/details/94211205%23%3A~%3Atext%3D06-11.%20990.%20%E4%B8%80%E3%80%81%20new%20operator%20%E4%B8%8E%20operator%20new%2C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%20%28%20new%20%EF%BC%8C%20operator%20new%20%29%E9%9D%A2%E9%9D%A2%E8%A7%82%20%EF%BC%88%E8%BD%AC%EF%BC%89).

连接里面的handle函数是自定义的异常处理函数。

[深入解析new、operator new、::new、placement new](https://link.zhihu.com/?target=https%3A//blog.csdn.net/songchuwang1868/article/details/81353577)

**面试管说还有一个placement new知道么？**

保持一块内存，反复构造析构，这样可以省略中间的多次分配内存。

在使用new关键字建立一个新的对象的时候，在编译器的第二步就是调用对象的构造函数生成类对象。这一步使用的就是placement new来实现的，即在取得了一块可以容纳指定类型对象的内存之后，在这块内存上构造一个对象。



参考链接：[C++中new、operator new和placement new的区别](https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_26822029/article/details/81213537)

**12、malloc的底层实现原理是什么？**

申请内存小于128k用brk（）函数。大于128k用mmap()函数。

具体细节参考：

[malloc 底层实现及原理 - 爱笑的张飞 - 博客园](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/zpcoding/p/10808969.html)

讲的很清楚了。

同时为了方便申请内存更加高效和减少内存碎片，使用了内存池的设计方式。

参考链接：[malloc底层实现及原理](https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/7af62431983e%23%3A~%3Atext%3Dmalloc%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%201%20malloc%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%20%23%E5%B0%86%E6%89%80%E6%9C%89%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98%E5%9D%97%E8%BF%9E%E6%88%90%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E8%AE%B0%E5%BD%95%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98%E5%9D%97%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%81%E5%A4%A7%E5%B0%8F%E7%AD%89%E4%BF%A1%E6%81%AF%202%2C%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%97%B6%EF%BC%8C%E6%89%BE%E5%88%B0%E5%A4%A7%E5%B0%8F%E5%90%88%E9%80%82%E7%9A%84%E5%9D%97%EF%BC%8C%E5%88%87%E6%88%90%E4%B8%A4%E4%BB%BD%EF%BC%8C%E4%B8%80%E5%88%86%E7%BB%99%E7%94%A8%E6%88%B7%EF%BC%8C%E4%B8%80%E4%BB%BD%E6%94%BE%E5%9B%9E%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%203%20free%E6%97%B6%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%8A%8A%E5%86%85%E5%AD%98%E5%9D%97%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%204%20%E8%A7%A3%E5%86%B3%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%EF%BC%9A%E5%B0%86%E8%83%BD%E5%A4%9F%E5%90%88%E5%B9%B6%E7%9A%84%E5%86%85%E5%AD%98%E5%9D%97%E8%BF%9B%E8%A1%8C%E5%90%88%E5%B9%B6)

**13、萃取机你知道么？它一般有什么作用？**

在STL中的模板有学过萃取机，顾名思义，它一般的作用就是将不同类型的数据通过萃取获得相同的表现形式，最常用的地方是迭代器。不同类型的迭代器都可以通过萃取机，调用相应的模板，从而实现特定的功能。

**14、C++的那些容器都是线程安全的还是非线程安全的？（大华面试）**

非线程安全的，也就说有可能多个线程对一个容器操作，造成一些抢占问题，可以加锁或者使用优先队列等方式进行解决。

**15、map底层是红黑树，那它的的插入方式有哪些？他们之间有什么区别？（大华）**

map<int, string> mapStudent;

(1)mapStudent.insert(pair<int, string>(1, "student_one"));

(2)mapStudent.insert(map<int, string>::value_type (1, "student_one"));

(3)mapStudent[1] = "student_one";

区别：数组方式可以覆盖，前两种不可以。当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对应的值。

参考链接：[map容器元素的三种插入方式_编程之路-CSDN博客](https://link.zhihu.com/?target=https%3A//blog.csdn.net/u012964993/article/details/21734657)

**16、Linux如何生成一个动态库？（大华）**

[gcc -fPIC -shared -o libmax.so](https://link.zhihu.com/?target=http%3A//gcc-fpic-shared-olibmax.so/) max.c

源文件是max.c，生成的动态库是[libmax.so](https://link.zhihu.com/?target=http%3A//gcc-fpic-shared-olibmax.so/)

参考链接：[Linux动态库生成与使用指南 - JollyWing - 博客园](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/jiqingwu/p/linux_dynamic_lib_create.html)

**17、Linux中socket通信链接端口的步骤？（大华）**

参考链接：[Linux实现简单的socket通信（TCP/IP）_HerofH_的博客-CSDN博客_linux实现socket](https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_28114615/article/details/88421575)

**18、一个类如何访问另一个类的private函数？（CVTE）**

设置友元类。

参考链接：[C++ 友元：在一个类中，调用另一个类的private方法。](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/leocc325/p/12852852.html)



**Linux进程间通信**

https://www.cnblogs.com/huansky/p/13170125.html

**tcp/ip 重点是三次握手和四次挥手**

https://www.51cto.com/article/597961.html

三次握手实际上对应的函数分别是

客户端调用connect方法，服务器端listen监听到，调用connect方法，然后发送ack包到客户端，建立连接

四次挥手其实是2*2，双方都需要单独关闭对应的发送窗口，一方发送close信号，告诉另外一方自己已经没有消息需要发送了，然后进入等待状态，另一方收到对方的close信号时，首先发送ack确认信号，表示自己已经知道对方要关闭了，此时如果发现自己还有信息需要传输，那么会等到信息传输完毕后调用close，告诉另外一方关闭连接，最后一次确认ack可能会在网络传输中丢失，导致连接无法关闭，故设置一个time_wait状态（2ms），在此期间丢失可以重传，2ms后双方都会关闭连接，此时连接彻底关闭。

- 中断连接端可以是客户端，也可以是服务器端。
- 第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。
- 第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。
- 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。
- 第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。

https://www.51cto.com/article/717235.html



作者：lancerK
链接：https://www.nowcoder.com/discuss/1056472?type=0&order=7&pos=3&page=2&source_id=discuss_center_0_nctrack&channel=1009&ncTraceId=48bfbe9a166f498c9afd6f402500656e.689.16638309284287267&gio_id=6E595043846F4BBC8517BE35D0EE3185-1663830929618
来源：牛客网



# 深信服C++一面  9.18                                                                                                                                                                                                                                                                                                                            

[![头像](https://images.nowcoder.com/images/20220412/208971387_1649749728016/D6969C98BC2C0947BA4D4AA0CDF33902?x-oss-process=image/resize,m_mfit,h_100,w_100)](        /profile/208971387    )

​                [lancerK](        /profile/208971387    )                                                                                                                                                                                                                                                                                                                                                                                                                                        

​                                                                                                      发布于  09-19 10:39                                                                                                          湖南                         

[                                                                  + 关注                             ](javascript:void(0))

  双非本硕，菜鸡一个，之前做的是[算法]()，后来转C++开发，基础确实没那么扎实。 

  昨天面试[深信服]()，面试官挺好的，不过我自己太菜了，准备的东西都没怎么问到哈哈哈麻了。 

  


- 自我介绍

  -  重点介绍：优势项，专业技能，以及比较有价值的项目经历
     

- 项目

  -  目标检测的项目问题（不是重点，但最好按照STAR原则来讲，感觉自己讲的不好，算减分项了）
  
- web服务器项目
  
  -  HTTP解析是自己写的吗？你对协议解析有什么了解？
     
  -  能支持断点续传吗？ 
     
    -  你怎么判断这是一个HTTP报文的?
    
  -  你对状态码有了解吗？重定向是哪个状态码？如果是重定向，服务器如何告诉客户端重定向到哪个页面？（某个字段）
     
  -  做完这个项目的收获是什么？
     
  
-  给一段代码，做题
   
-  宏函数和内联函数解释，宏函数和内联函数的区别？编译之后内联函数还是一个独立的函数吗，宏函数呢？
   宏定义不检查函数参数，返回值什么的，只是展开，相对来说，内联函数会检查参数类型，所以更安全。 内联函数和宏很类似，而区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。 而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。

-  static修饰的函数外部文件能调用吗？为什么不可以？

- static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。 static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。 

-  STL容器有哪些，实现原理讲一下？vector的扩容过程？hash表出现hash冲突后采用什么方法？
   
-  继承 多态，使用场景？ 重载和覆盖的区别？为什么C++可以有重名函数？虚函数考察？在C程序中直接调用C++的库会成功吗？为什么？
   
-  volatile修饰？ 
   
-  智能指针？ 智能指针怎么知道自己的生命周期结束的？引用计数？
   
-  C++的类对象可以用memset进行初始化吗？如果只有正常的成员变量和方法可以吗？
   
-  不可以
   
-  快速在字符串里面找到子字符串用什么方法？解释KMP？多模匹配的时候用什么[算法]()？
   
-  10万个号码，都是6位数，查找某个号码在不在集合中？最好时间复杂度为O(1) 
   
-  快排，归并排解释和应用场景？
   
-  三次握手？为什么是四次挥手？客户端先发起关闭请求还是服务端？为什么？
   
-  TCP滑动窗口？
   
-  浏览器访问域名的过程？ 

   肯定凉凉了，感谢[深信服]()，希望下次有机会再来，基础要打牢！！！



一面：

堆与栈的区别可以总结为以下6方面：
1) 管理方式不同：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak

2) 空间大小不同：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M

3) 碎片问题：对于堆来讲，频繁的new/ delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在它上面的后进的栈内容已经被弹出

4) 生长方向不同：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。

5) 分配方式不同：堆都是动态分配的，没有静态分配的堆。内存有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloc,calloc函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 

6) 分配效率不同：栈由系统自动分配，速度较快。但程序员无法控制。堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。

new和malloc区别

当我回答到new底层实际上也是调用的malloc时他表示对对。。。

c和c++区别（两次）

tcp和udp区别(两次)

c基本数据类型

重载，重写和隐藏的区别

代码，两段代码的运行结果，实际上都有bug完全不能执行，属于坑

```cpp
void test(int *p)
{
    p = 1;
}

int &test2()
{
    int a = 1;
    return &a;
}
```

算法题：找到链表的第K个节点（双指针没什么好说的）

然后还问了一部分socket的函数，比如send和recv

震旦科技笔试题：

1、const static voliate关键字

2、用变量a给出下面的定义 （笔试遇到两次了，一模一样）                                                                                                                                                                                                                                                            

a) 一个整型数（An integer）

 int a;                                                                                                                                                                                                                                                         

b)一个指向整型数的指针（ A pointer to an integer） 

 int *a;                                                                                                                                                                                                                                              

c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）

int **a;                                                                                                                                                                                                               

d)一个有10个整型数的数组（ An array of 10 integers）  

int a[10];

e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers）

int *a[10];                                                                                                                                                                                                                          

f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers）  

 int (*a)[10];                                                                                                                                                                                                                                 

g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）

  int (*a)(int);                                                                                                                                                                                             

h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）                                                                                                                                                                           

  int(*a[10])(int);   

然后是涉及找bug的函数，主要考察的是strcpy以及strlen，之前的有点记不住，最后一个因为不确定记下来了

```cpp
//有两个错误
swap(int *a, int *b)//1、无显式指定返回值，注意这个错误只有c++会报错，c是不会报错的
{
    int *t;
    *t = *a;//错误2
    *a = *b;
    *b = *t;
}
```

然后是代码题，自行实现memcpy